/*
 * generated by Xtext 2.10.0
 */
package uk.ac.ox.cs.xdrone.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class XDroneGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ProgramElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uk.ac.ox.cs.xdrone.XDrone.Program");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cSubProgramsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cSubProgramsFunParserRuleCall_0_0 = (RuleCall)cSubProgramsAssignment_0.eContents().get(0);
		private final Assignment cMainAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cMainMainParserRuleCall_1_0 = (RuleCall)cMainAssignment_1.eContents().get(0);
		
		//Program:
		//	subPrograms+=Fun*
		//	main=Main;
		@Override public ParserRule getRule() { return rule; }
		
		//subPrograms+=Fun* main=Main
		public Group getGroup() { return cGroup; }
		
		//subPrograms+=Fun*
		public Assignment getSubProgramsAssignment_0() { return cSubProgramsAssignment_0; }
		
		//Fun
		public RuleCall getSubProgramsFunParserRuleCall_0_0() { return cSubProgramsFunParserRuleCall_0_0; }
		
		//main=Main
		public Assignment getMainAssignment_1() { return cMainAssignment_1; }
		
		//Main
		public RuleCall getMainMainParserRuleCall_1_0() { return cMainMainParserRuleCall_1_0; }
	}
	public class FunElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uk.ac.ox.cs.xdrone.XDrone.Fun");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFunKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cInputKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cParametersAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cParametersParameterParserRuleCall_2_1_0 = (RuleCall)cParametersAssignment_2_1.eContents().get(0);
		private final Assignment cBodyAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBodyBodyParserRuleCall_3_0 = (RuleCall)cBodyAssignment_3.eContents().get(0);
		
		//Fun:
		//	'fun' name=ID ('input' parameters+=Parameter*)?
		//	body=Body;
		@Override public ParserRule getRule() { return rule; }
		
		//'fun' name=ID ('input' parameters+=Parameter*)? body=Body
		public Group getGroup() { return cGroup; }
		
		//'fun'
		public Keyword getFunKeyword_0() { return cFunKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//('input' parameters+=Parameter*)?
		public Group getGroup_2() { return cGroup_2; }
		
		//'input'
		public Keyword getInputKeyword_2_0() { return cInputKeyword_2_0; }
		
		//parameters+=Parameter*
		public Assignment getParametersAssignment_2_1() { return cParametersAssignment_2_1; }
		
		//Parameter
		public RuleCall getParametersParameterParserRuleCall_2_1_0() { return cParametersParameterParserRuleCall_2_1_0; }
		
		//body=Body
		public Assignment getBodyAssignment_3() { return cBodyAssignment_3; }
		
		//Body
		public RuleCall getBodyBodyParserRuleCall_3_0() { return cBodyBodyParserRuleCall_3_0; }
	}
	public class ParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uk.ac.ox.cs.xdrone.XDrone.Parameter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeTypeParserRuleCall_1_0 = (RuleCall)cTypeAssignment_1.eContents().get(0);
		
		//Parameter:
		//	name=ID
		//	type=Type;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID type=Type
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//type=Type
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }
		
		//Type
		public RuleCall getTypeTypeParserRuleCall_1_0() { return cTypeTypeParserRuleCall_1_0; }
	}
	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uk.ac.ox.cs.xdrone.XDrone.Type");
		private final Keyword cNumberKeyword = (Keyword)rule.eContents().get(1);
		
		//Type:
		//	'number';
		@Override public ParserRule getRule() { return rule; }
		
		//'number'
		public Keyword getNumberKeyword() { return cNumberKeyword; }
	}
	public class MainElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uk.ac.ox.cs.xdrone.XDrone.Main");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMainKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cInputKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cParametersAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cParametersParameterParserRuleCall_2_1_0 = (RuleCall)cParametersAssignment_2_1.eContents().get(0);
		private final Keyword cBeginKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Assignment cCommandsAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final RuleCall cCommandsCommandParserRuleCall_4_0_0 = (RuleCall)cCommandsAssignment_4_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_4_1 = (Keyword)cGroup_4.eContents().get(1);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cReturnKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final RuleCall cCommandParserRuleCall_5_1 = (RuleCall)cGroup_5.eContents().get(1);
		private final Keyword cEndKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//Main:
		//	'main' name=ID ('input' parameters+=Parameter*)?
		//	'begin' (commands+=Command ';'?)* ('return' Command)?
		//	'end';
		@Override public ParserRule getRule() { return rule; }
		
		//'main' name=ID ('input' parameters+=Parameter*)? 'begin' (commands+=Command ';'?)* ('return' Command)? 'end'
		public Group getGroup() { return cGroup; }
		
		//'main'
		public Keyword getMainKeyword_0() { return cMainKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//('input' parameters+=Parameter*)?
		public Group getGroup_2() { return cGroup_2; }
		
		//'input'
		public Keyword getInputKeyword_2_0() { return cInputKeyword_2_0; }
		
		//parameters+=Parameter*
		public Assignment getParametersAssignment_2_1() { return cParametersAssignment_2_1; }
		
		//Parameter
		public RuleCall getParametersParameterParserRuleCall_2_1_0() { return cParametersParameterParserRuleCall_2_1_0; }
		
		//'begin'
		public Keyword getBeginKeyword_3() { return cBeginKeyword_3; }
		
		//(commands+=Command ';'?)*
		public Group getGroup_4() { return cGroup_4; }
		
		//commands+=Command
		public Assignment getCommandsAssignment_4_0() { return cCommandsAssignment_4_0; }
		
		//Command
		public RuleCall getCommandsCommandParserRuleCall_4_0_0() { return cCommandsCommandParserRuleCall_4_0_0; }
		
		//';'?
		public Keyword getSemicolonKeyword_4_1() { return cSemicolonKeyword_4_1; }
		
		//('return' Command)?
		public Group getGroup_5() { return cGroup_5; }
		
		//'return'
		public Keyword getReturnKeyword_5_0() { return cReturnKeyword_5_0; }
		
		//Command
		public RuleCall getCommandParserRuleCall_5_1() { return cCommandParserRuleCall_5_1; }
		
		//'end'
		public Keyword getEndKeyword_6() { return cEndKeyword_6; }
	}
	public class BodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uk.ac.ox.cs.xdrone.XDrone.Body");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBlockExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cBeginKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cCommandsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cCommandsCommandParserRuleCall_2_0_0 = (RuleCall)cCommandsAssignment_2_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cReturnKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final RuleCall cCommandParserRuleCall_3_1 = (RuleCall)cGroup_3.eContents().get(1);
		private final Keyword cEndKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Body BlockExpression:
		//	{BlockExpression}
		//	'begin' (commands+=Command ';'?)* ('return' Command)?
		//	'end'
		@Override public ParserRule getRule() { return rule; }
		
		//{BlockExpression} 'begin' (commands+=Command ';'?)* ('return' Command)? 'end'
		public Group getGroup() { return cGroup; }
		
		//{BlockExpression}
		public Action getBlockExpressionAction_0() { return cBlockExpressionAction_0; }
		
		//'begin'
		public Keyword getBeginKeyword_1() { return cBeginKeyword_1; }
		
		//(commands+=Command ';'?)*
		public Group getGroup_2() { return cGroup_2; }
		
		//commands+=Command
		public Assignment getCommandsAssignment_2_0() { return cCommandsAssignment_2_0; }
		
		//Command
		public RuleCall getCommandsCommandParserRuleCall_2_0_0() { return cCommandsCommandParserRuleCall_2_0_0; }
		
		//';'?
		public Keyword getSemicolonKeyword_2_1() { return cSemicolonKeyword_2_1; }
		
		//('return' Command)?
		public Group getGroup_3() { return cGroup_3; }
		
		//'return'
		public Keyword getReturnKeyword_3_0() { return cReturnKeyword_3_0; }
		
		//Command
		public RuleCall getCommandParserRuleCall_3_1() { return cCommandParserRuleCall_3_1; }
		
		//'end'
		public Keyword getEndKeyword_4() { return cEndKeyword_4; }
	}
	public class CommandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uk.ac.ox.cs.xdrone.XDrone.Command");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cHomeKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cEmergencyStopKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cUPKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cDOWNKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cLEFTKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cRIGHTKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cFORWARDKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cBACKWARDKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		
		//Command:
		//	'home' | 'emergencyStop' | 'UP' | 'DOWN' | 'LEFT' | 'RIGHT' |
		//	'FORWARD' | 'BACKWARD';
		@Override public ParserRule getRule() { return rule; }
		
		//'home' | 'emergencyStop' | 'UP' | 'DOWN' | 'LEFT' | 'RIGHT' | 'FORWARD' | 'BACKWARD'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'home'
		public Keyword getHomeKeyword_0() { return cHomeKeyword_0; }
		
		//'emergencyStop'
		public Keyword getEmergencyStopKeyword_1() { return cEmergencyStopKeyword_1; }
		
		//'UP'
		public Keyword getUPKeyword_2() { return cUPKeyword_2; }
		
		//'DOWN'
		public Keyword getDOWNKeyword_3() { return cDOWNKeyword_3; }
		
		//'LEFT'
		public Keyword getLEFTKeyword_4() { return cLEFTKeyword_4; }
		
		//'RIGHT'
		public Keyword getRIGHTKeyword_5() { return cRIGHTKeyword_5; }
		
		//'FORWARD'
		public Keyword getFORWARDKeyword_6() { return cFORWARDKeyword_6; }
		
		//'BACKWARD'
		public Keyword getBACKWARDKeyword_7() { return cBACKWARDKeyword_7; }
	}
	public class ExecutableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uk.ac.ox.cs.xdrone.XDrone.Executable");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cProgramParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFunParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Executable:
		//	Program | Fun;
		@Override public ParserRule getRule() { return rule; }
		
		//Program | Fun
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Program
		public RuleCall getProgramParserRuleCall_0() { return cProgramParserRuleCall_0; }
		
		//Fun
		public RuleCall getFunParserRuleCall_1() { return cFunParserRuleCall_1; }
	}
	public class AdditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uk.ac.ox.cs.xdrone.XDrone.Addition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAdditionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightMultiplicationParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// *
		// * Here we have the expression handling
		// * / Addition Expression:
		//	Multiplication ({Addition.left=current} '+' right=Multiplication)*
		@Override public ParserRule getRule() { return rule; }
		
		//Multiplication ({Addition.left=current} '+' right=Multiplication)*
		public Group getGroup() { return cGroup; }
		
		//Multiplication
		public RuleCall getMultiplicationParserRuleCall_0() { return cMultiplicationParserRuleCall_0; }
		
		//({Addition.left=current} '+' right=Multiplication)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Addition.left=current}
		public Action getAdditionLeftAction_1_0() { return cAdditionLeftAction_1_0; }
		
		//'+'
		public Keyword getPlusSignKeyword_1_1() { return cPlusSignKeyword_1_1; }
		
		//right=Multiplication
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Multiplication
		public RuleCall getRightMultiplicationParserRuleCall_1_2_0() { return cRightMultiplicationParserRuleCall_1_2_0; }
	}
	public class MultiplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uk.ac.ox.cs.xdrone.XDrone.Multiplication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMultiplicationLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAsteriskKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPrimaryParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Multiplication Expression:
		//	Primary ({Multiplication.left=current} '*' right=Primary)*
		@Override public ParserRule getRule() { return rule; }
		
		//Primary ({Multiplication.left=current} '*' right=Primary)*
		public Group getGroup() { return cGroup; }
		
		//Primary
		public RuleCall getPrimaryParserRuleCall_0() { return cPrimaryParserRuleCall_0; }
		
		//({Multiplication.left=current} '*' right=Primary)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Multiplication.left=current}
		public Action getMultiplicationLeftAction_1_0() { return cMultiplicationLeftAction_1_0; }
		
		//'*'
		public Keyword getAsteriskKeyword_1_1() { return cAsteriskKeyword_1_1; }
		
		//right=Primary
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Primary
		public RuleCall getRightPrimaryParserRuleCall_1_2_0() { return cRightPrimaryParserRuleCall_1_2_0; }
	}
	public class PrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uk.ac.ox.cs.xdrone.XDrone.Primary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNumberParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cAdditionParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//Primary Expression:
		//	Number | '(' Addition ')'
		@Override public ParserRule getRule() { return rule; }
		
		//Number | '(' Addition ')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Number
		public RuleCall getNumberParserRuleCall_0() { return cNumberParserRuleCall_0; }
		
		//'(' Addition ')'
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//Addition
		public RuleCall getAdditionParserRuleCall_1_1() { return cAdditionParserRuleCall_1_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}
	public class NumberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uk.ac.ox.cs.xdrone.XDrone.Number");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//Number:
		//	value=INT;
		@Override public ParserRule getRule() { return rule; }
		
		//value=INT
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//INT
		public RuleCall getValueINTTerminalRuleCall_0() { return cValueINTTerminalRuleCall_0; }
	}
	
	
	private final ProgramElements pProgram;
	private final FunElements pFun;
	private final ParameterElements pParameter;
	private final TypeElements pType;
	private final MainElements pMain;
	private final BodyElements pBody;
	private final CommandElements pCommand;
	private final ExecutableElements pExecutable;
	private final AdditionElements pAddition;
	private final MultiplicationElements pMultiplication;
	private final PrimaryElements pPrimary;
	private final NumberElements pNumber;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public XDroneGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pProgram = new ProgramElements();
		this.pFun = new FunElements();
		this.pParameter = new ParameterElements();
		this.pType = new TypeElements();
		this.pMain = new MainElements();
		this.pBody = new BodyElements();
		this.pCommand = new CommandElements();
		this.pExecutable = new ExecutableElements();
		this.pAddition = new AdditionElements();
		this.pMultiplication = new MultiplicationElements();
		this.pPrimary = new PrimaryElements();
		this.pNumber = new NumberElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("uk.ac.ox.cs.xdrone.XDrone".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Program:
	//	subPrograms+=Fun*
	//	main=Main;
	public ProgramElements getProgramAccess() {
		return pProgram;
	}
	
	public ParserRule getProgramRule() {
		return getProgramAccess().getRule();
	}
	
	//Fun:
	//	'fun' name=ID ('input' parameters+=Parameter*)?
	//	body=Body;
	public FunElements getFunAccess() {
		return pFun;
	}
	
	public ParserRule getFunRule() {
		return getFunAccess().getRule();
	}
	
	//Parameter:
	//	name=ID
	//	type=Type;
	public ParameterElements getParameterAccess() {
		return pParameter;
	}
	
	public ParserRule getParameterRule() {
		return getParameterAccess().getRule();
	}
	
	//Type:
	//	'number';
	public TypeElements getTypeAccess() {
		return pType;
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}
	
	//Main:
	//	'main' name=ID ('input' parameters+=Parameter*)?
	//	'begin' (commands+=Command ';'?)* ('return' Command)?
	//	'end';
	public MainElements getMainAccess() {
		return pMain;
	}
	
	public ParserRule getMainRule() {
		return getMainAccess().getRule();
	}
	
	//Body BlockExpression:
	//	{BlockExpression}
	//	'begin' (commands+=Command ';'?)* ('return' Command)?
	//	'end'
	public BodyElements getBodyAccess() {
		return pBody;
	}
	
	public ParserRule getBodyRule() {
		return getBodyAccess().getRule();
	}
	
	//Command:
	//	'home' | 'emergencyStop' | 'UP' | 'DOWN' | 'LEFT' | 'RIGHT' |
	//	'FORWARD' | 'BACKWARD';
	public CommandElements getCommandAccess() {
		return pCommand;
	}
	
	public ParserRule getCommandRule() {
		return getCommandAccess().getRule();
	}
	
	//Executable:
	//	Program | Fun;
	public ExecutableElements getExecutableAccess() {
		return pExecutable;
	}
	
	public ParserRule getExecutableRule() {
		return getExecutableAccess().getRule();
	}
	
	/// *
	// * Here we have the expression handling
	// * / Addition Expression:
	//	Multiplication ({Addition.left=current} '+' right=Multiplication)*
	public AdditionElements getAdditionAccess() {
		return pAddition;
	}
	
	public ParserRule getAdditionRule() {
		return getAdditionAccess().getRule();
	}
	
	//Multiplication Expression:
	//	Primary ({Multiplication.left=current} '*' right=Primary)*
	public MultiplicationElements getMultiplicationAccess() {
		return pMultiplication;
	}
	
	public ParserRule getMultiplicationRule() {
		return getMultiplicationAccess().getRule();
	}
	
	//Primary Expression:
	//	Number | '(' Addition ')'
	public PrimaryElements getPrimaryAccess() {
		return pPrimary;
	}
	
	public ParserRule getPrimaryRule() {
		return getPrimaryAccess().getRule();
	}
	
	//Number:
	//	value=INT;
	public NumberElements getNumberAccess() {
		return pNumber;
	}
	
	public ParserRule getNumberRule() {
		return getNumberAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/ *'->'* /';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
